

### 1、torchvision.transforms.ToTensor()

`torchvision.transforms.ToTensor()`  做了三件事：

1、将图像的数据格式由 nump.ndarray 或 PIL.Image 转为 tensor，数据类型为 torch.FloatTensor
2、将像素值范围从 0-255 转换到 0-1之间， 处理方式 ：直接除以255
3、将 shape=(H,W, C)  转换为 shape= (C, H, W)



---



### 2、torchvision.transforms.Normalize()

作用：用均值和标准差对张量图像进行归一化 （一般在 `torchvision.transforms.ToTensor()` 之后使用）

公式：$image = \frac{image-mean}{std}$

比如，在使用 `torchvision.transforms.ToTensor()`  之后，像素值取值范围会被转换到 [0, 1]之间，再使用 `transforms.Normalize(mean, std)` 进行归一化后，原像素值就被分布到了 [-1, 1] 之间：

- 原来的 0~1 最小值 0 则变成 (0 - mean) / std = -1
- 最大值1则变成  (1 - mean) / std = 1

一般 mean 和 std 会分别指定3个值，代表图像3个通道的均值和方差，比如`torchvision.transforms.Normalize(mean=[0.5, 0.5, 0.5], std=[0.5, 0.5, 0.5])`

如果是单通道的灰度图，均值为0.5，方差为0.5，可以写成 `transforms.Normalize(mean=[0.5], std=[0.5])`

我们可能会看到很多代码里面是这样写的：
`torchvision.transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])`
这一组值是怎么来的呢？答案就是 ：通过 ImageNet数据集，提前计算出来的。 因为  ImageNet数据集 是一个大型数据集，由一个大型数据集统计出来的均值和方差，基本符合所有数据集的像素值分布，所以可以直接使用。

重新计算并使用自己数据集的均值和方差也是可以的，就是开销比较大，所以，一般直接使用 `mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]`


